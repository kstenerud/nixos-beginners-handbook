Building packages using flakes
==============================


A basic build flake
-------------------

As a quick introduction, we'll look at the super basic flake file generated by `nix flake init`.

```
$ nix flake init
```

This creates a file `flake.nix` containing:

```
{
  description = "A very basic flake";

  outputs = { self, nixpkgs }: {

    packages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;

    defaultPackage.x86_64-linux = self.packages.x86_64-linux.hello;

  };
}
```

`outputs` is a function that takes an input of at least `self`, and then whatever other things it needs to produce its output. In this case it needs `nixpkgs` because it's going to make a reference to `hello` from `legacyPackages`.

The set generated by the `outputs` function contains two things:

- `packages.x86_64-linux.hello`: The `hello` package, following the Nix flake convention of `packages.<system>.<package-name>`
- `defaultPackage.x86_64-linux`: This gets used whenever you don't specify a target in a nix commnd.

You technically don't need `defaultPackage`, but it makes things nicer because Nix will use that target whenever none is specified (e.g. `nix build`). Otherwise, you must always specify your target (e.g. `nix build .#hello`)

You can see the targets from the command line using `nix flake show` (which defaults to the `flake.nix` in the current directory):

```
$ nix flake show
path:/home/karl/myflake?narHash=sha256-5wEXeNZqnqtiCXbGAuV287BI%2fVtU3xqkDBnB0CpalsA=
├───defaultPackage
│   └───x86_64-linux: package 'hello-2.10'
└───packages
    └───x86_64-linux
        └───hello: package 'hello-2.10'

```

You can build it like so:

```
$ nix build
warning: creating lock file '/home/karl/myflake/flake.lock'
```

`flake.lock` records the hashes of the current environment to ensure that any future builds will use the exact same environment to produce the exact same result:

```
$ cat flake.lock 
{
  "nodes": {
    "nixpkgs": {
      "locked": {
        "lastModified": 1629139728,
        "narHash": "sha256-XuddZZNg61qSLsczyYGg/bugA+zR7I394Ev8A8SrdoY=",
        "path": "/nix/store/lq6cqr7n4rhmmjfkmsdzaqj3hnj3yhrg-source",
        "rev": "94c989365d563238068841763ecc5f7f4b25b22c",
        "type": "path"
      },
      "original": {
        "id": "nixpkgs",
        "type": "indirect"
      }
    },
    "root": {
      "inputs": {
        "nixpkgs": "nixpkgs"
      }
    }
  },
  "root": "root",
  "version": 7
}
```

It also makes a symlink `result`, which points to where the package actually is in your Nix store.

```
$ ls -l
total 8
-rw-r--r-- 1 karl users 523 Aug 23 17:43 flake.lock
-rw-r--r-- 1 karl users 229 Aug 23 17:43 flake.nix
lrwxrwxrwx 1 karl users  54 Aug 23 17:43 result -> /nix/store/fjc71ycmr5fnfxyfgwi2dwh323z12gvq-hello-2.10
```

We can invoke the program it "built" like so:

```
$ ./result/bin/hello 
Hello, world!
```



Building a real package
-----------------------

Let's make our own program and package it! All Nix flakes must be inside of a repository, so let's start one:

```
git init myhello
cd myhello
```

We need a program to build:

```
cat <<'EOF' >myhello.c
#include <stdio.h>
int main() {
    printf("Hello My World\n");
    return 0;
}
EOF
git add myhello.c
```

Next, we need a `flake.nix` file. If you can't remember what they should look like, use the handy `nix flake init` to generate a basic one for you. Here's our `flake.nix`:

```
cat <<'EOF' >flake.nix
{
  description = "A flake for building My Hello World";

  inputs.nixpkgs.url = github:NixOS/nixpkgs/nixos-21.05;

  outputs = { self, nixpkgs }: {

    packages.x86_64-linux.myhello = 
      with import nixpkgs { system = "x86_64-linux"; };
      stdenv.mkDerivation {
        name = "myhello";
        src = self;
        buildPhase = "gcc -o myhello ./myhello.c";
        installPhase = "mkdir -p $out/bin; install -t $out/bin myhello";
      };
    defaultPackage.x86_64-linux = self.packages.x86_64-linux.myhello;
  };
}
EOF
git add flake.nix
```

* Our package is called `myhello`.
* We're using NixOS 21.05 as a build environment.
* We're defining a build for `x86_64-linux`.
* Our source is in the current directory `src = self`.
* Our build phase (`buildPhase`) compiles `myhello.c` to produce `myhello`.
* Our install phase (`installPhase`) makes a `bin` dir in this package's result and then installs `myhello` there.

To build it:

```
$ nix build
warning: Git tree '/home/karl/myhello' is dirty
warning: creating lock file '/home/karl/myhello/flake.lock'
warning: Git tree '/home/karl/myhello' is dirty
```

Note: You can shut up these warnings by committing to the git repo.

`nix build` will run `buildPhase` and make a symlink to the result in the current directory:

```
$ ls -l
total 12
-rw-r--r-- 1 karl users 564 Aug 23 17:25 flake.lock
-rw-r--r-- 1 karl users 527 Aug 23 17:25 flake.nix
-rw-r--r-- 1 karl users  80 Aug 23 17:24 myhello.c
lrwxrwxrwx 1 karl users  51 Aug 23 17:25 result -> /nix/store/yfxacvx36jgrlar4ma84gpd8w7dii437-myhello
```

You'll want to add `result` to your `.gitignore` file:

```
echo "result" >>.gitignore
git add .gitignore
```

After building, you can directly call your new program like so:

```
$ ./result/bin/myhello 
Hello My World
```

Instead of `nix build`, you could invoke it directly via the nix shell (which will do the build if necessary):

```
$ nix shell --command myhello
Hello My World
```

Or you could open a development shell, which allows you to call or evaluate the different phases manually:

```
$ nix develop

$ eval "$buildPhase"

$ ls
flake.lock  flake.nix  myhello  myhello.c

$ ./myhello 
Hello My World

$ exit
exit

$ rm myhello
```

Once you're happy with your flake, you can commit your files:

```
git add .gitignore flake.lock flake.nix myhello.c
git commit -m "Initial commit"
```

You can now publish it so that others can use it:

```
$ git remote add origin git@github.com:myusername/myhello.git
$ git push -u origin main
```

Now others can invoke your program like so:

```
$ nix shell github:myusername/myhello -c myhello
Hello My World
```

